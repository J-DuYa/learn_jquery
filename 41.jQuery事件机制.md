#### Dom事件处理模型

`element.addEventListener('click', doSomething, false)`

1. 如果页面大量元素都需要事件绑定会导致性能问题，而且还需要解绑（IE会泄漏）
2. 绑定的元素必须要存在
3. 后期生成HTML会没有事件绑定，需要重新绑定


jQuery提供4种事件绑定方式:

* `.bind()`
* `.live()` 1.7版本后已不推荐使用
* `.delegate()`
* `.on()`

以上四种方法归根到底仍是调用了`addEventListener`

#### 使用事件委托

利用事件冒泡机制实现委托。参考[Event Phases](https://github.com/ttian226/javascript-issues/blob/master/Event/Event%20Phases.md)
事件委托就是事件目标自身不处理事件，而是把处理任务委托给其父元素或者祖先元素，甚至根元素（document）

*不使用委托，需要绑定多次事件*

```javascript
(function() {
    var resources = document.getElementById('resources'),
        links = document.getElementsByTagName('a'),
        len = links.length;

    for (var i = 0; i < len; i++) {
        // 循环绑定事件
        links[i].addEventListener('click', handler, false);
    }

    function handler(e) {
        var target = e.target;
        // target为目标<a>, 这里输出实际上调用了toString()方法
        console.log('addEventListener绑定:' + target);
        e.preventDefault();
    }
})();
```

*使用委托，只需要绑定一次*

```javascript
(function() {
    var resources = document.getElementById('resources');

    // 绑定父元素
    resources.addEventListener('click', handler, false);

    function handler(e) {
        var target = e.target;

        if (target.nodeName.toLowerCase() === 'a') {
            console.log('事件委托:' + target);
            e.preventDefault();
        }
    }
})();
```
